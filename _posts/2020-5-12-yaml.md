---
layout: post
title: Working with YAML in Python
tags: [ python, automation ]
image: /img/python-logo.jpg
---


```python
d = {
  'string' : 'string',
  'list': ['item-1', 'item-2',],
  'set' : {'router-1', 'router-2', 'router-3',},
  'tuple' : ('switch-1', 'switch-2'),
  'nested-dictionary' : { 
    'key-1' : 'value-1',
    'key-2' : 'value-2',
  },
  'True' : True,
  'False' : False,
  'None' : None,
}
```

```yaml
# >>> print(yaml.dump(d,sort_keys=False))
string: string
list:
- item-1
- item-2
set: !!set
  router-2: null
  router-3: null
  router-1: null
tuple: !!python/tuple
- switch-1
- switch-2
nested-dictionary:
  key-1: value-1
  key-2: value-2
'True': true
'False': false
None: null
```

```yaml
paris:
  as: 65000
  syslog: 

spine-2:
leaf-1:
leaf-2:
```



| Python data structures | serializes to YAML |
| ---------------------- | ------------------ |
| dict                   | object             |
| list, tuple            | array              |
| str                    | string             |
| int, float             | number             |
| True                   | true               |
| False                  | false              |
| None                   | null               |



| YAML value         | deserializes to Python |
| ------------------ | ---------------------- |
| object             | dict                   |
| array              | list                   |
| string             | str                    |
| number             | int, float             |
| true               | True                   |
| false              | False                  |
| null               | None                   |




### Emit a Python object as a string of YAML

The <b>dump</b> method is used to serialize a Python object into a YAML stream. In the next example, we emit the Python dictionary as a string:

```python
import yaml

d = {
  'True' : True,
  'False' : False,
  'None' : None,
}

print(yaml.dump(d))
```

The script will output the following:

<pre style="font-size:12px">
'False': false
None: null
'True': true
</pre>

Dump will sort the keys for you. If this is not what you want, use the following to change it:


```python
import yaml

d = {
  'a' : 'a',
  'e' : 'e',      
  'b' : 'b',
  'd' : 'd',
  'c' : 'c',  
}

print(yaml.dump(d, sort_keys=False))
```

This will output the following:

<pre style="font-size:12px">
a: a
e: e
b: b
d: d
c: c
</pre>

### Dump Python object as YAML in a file:

Here, we use the <b>dump</b> method to write a Python object to a file we just opened:

```python
import yaml

d = { 'key' : 'value' }
with open("example.yaml", "w") as fh:  
  (yaml.dump(d, fh))
```

Sometimes, you'll see the dump method used to emit YAML as a string, and write that string to a file like so:

```python
import yaml

d = { 'key' : 'value' }
with open("example.yaml", "w") as fh:  
  fh.write(yaml.dump(d))
```

Both examples result in the following YAML file:

<pre style="font-size:12px">
[root@said ~]$ more example.yaml 
{key: value}
</pre>

### Create a Python object from a YAML string

```python
import yaml

yaml_string = """
France:
  capital: Paris
Italy:
  capital: Rome
list_of_items:
  - item 1
  - item 2
  - item 3  
"""

python_object = yaml.load(yaml_string, Loader=yaml.FullLoader)
print(python_object)
```

This script outputs the following:
<pre style="font-size:12px">
{'France': {'capital': 'Paris'}, 'Italy': {'capital': 'Rome'}, 'list_of_items': ['item 1', 'item 2', 'item 3']}
</pre>


### Create a Python object from a YAML file

```python
import yaml
yaml_file = "example.yaml"
with open(yaml_file, "r") as fh:
  python_object = yaml.load(fh, Loader=yaml.FullLoader)

print(python_object)
```











### Dictify a web page

### Using YAML in jinja

====



YAML: YAML Ain't Markup Language

What It Is: YAML is a human friendly data serialization
  standard for all programming languages.


Links:
https://yaml.org/

https://noyaml.com/

Interesting from https://yaml.org/spec/1.2/spec.html 1.3. Relation to JSON:


https://github.com/yaml/pyyaml

```
Both JSON and YAML aim to be human readable data interchange formats. However, JSON and YAML have different priorities. JSON’s foremost design goal is simplicity and universality. Thus, JSON is trivial to generate and parse, at the cost of reduced human readability. It also uses a lowest common denominator information model, ensuring any JSON data can be easily processed by every modern programming environment.

In contrast, YAML’s foremost design goals are human readability and support for serializing arbitrary native data structures. Thus, YAML allows for extremely readable files, but is more complex to generate and parse. In addition, YAML ventures beyond the lowest common denominator data types, requiring more complex processing when crossing between different programming environments.

YAML can therefore be viewed as a natural superset of JSON, offering improved human readability and a more complete information model. This is also the case in practice; every JSON file is also a valid YAML file. This makes it easy to migrate from JSON to YAML if/when the additional features are required.
```

Some of YAMLs basic characteristics are the following:
- YAML is case-sensitive
- YAML does not ignore whitespaces
- YAML uses indents for structure
- YAML uses spaces, not tabs
- it is customary to start YAML documents with three dashes '---' (not required)
- Comments start with a '#'
- Strings do not need quotes unless they include special characters
- YAML structures:
  * mappings
  * sequences


YAML mappings.
Mappings are key-value pairs, similar to JSON objects. Example of a mapping:
---
name : Bob
height : 6 foot

YAML sequences.

Sequences are lists or arrays of data, and are similar to JSON arrays. Sequence items start with a dash, example:

---
-apple
-orange
-banana

Sequences do not have to have a name associated with them.



```python
sa
```



===
A LAG combines multiple physical links between two adjacent nodes together to establish a single (virtual) link. This offers increased bandwidth, link efficiency and physical redundancy.

In order to make protocols that run across the LAG rapidly detect failures, you can configure them with BFD. BFD supports OSPF, IS-IS, BGP, LDP, RSVP, static routes and more. 

In some networks, BFD is configured for multiple protocols at the same time. But did you know that you can also protect a LAG using BFD? And that this protection also helps the higher-layer protocols to respond faster?

### Micro-BFD on LAG interfaces


When BFD is used as a liveness detection protocol for a LAG, micro-BFD sessions will monitor the forwarding path of the links between the two systems. The BFD sessions that are protecting the member links are independent BFD sessions. There is one BFD session per link that is part of the LAG. When BFD detects a failure in the path of a link, the child of the LAG is brought down. This way, BFD can detect failures in the forwarding path of a child link and ensure that it is brought down swiftly.

The BFD protected LAG will be able to respond to failures as fast as the BFD timers you configure. This in turn ensures that higher layer-protocols (such as OSPF, LDP or BGP) will be able to respond quickly to the loss of connectivity. This is because protocols running across interfaces will react nearly instantaneously to an interface down event.

Consider an OSPF neighbor relationship with a dead timer of 40 seconds. When the underlying interface that is used to sustain the OSPF session is brought down by BFD, the system does not have to wait for the dead timer to reach 0. As soon as the LAG is brought down, the OSPF session is removed and alternate routes (if any) are considered. 

The same thing goes for other protocols and this makes it a strategy that can work out well for all sorts of networks, be it an MPLS core or a clos fabric.


### Configuring BFD for a LAG on Juniper MX


{:refdef: style="text-align: center;"}
![Juniper BFD protected LAG on MX](/img/juniper_lag_bfd.png "Juniper BFD protected LAG")
{: refdef}

Let's start out configuring the LAG with its 4 child links. To this end, we configure the following:

<b>vMX-1</b>:

<pre style="font-size:12px">
set chassis aggregated-devices ethernet device-count 20

set interfaces ge-0/0/4 gigether-options 802.3ad ae0
set interfaces ge-0/0/5 gigether-options 802.3ad ae0
set interfaces ge-0/0/6 gigether-options 802.3ad ae0
set interfaces ge-0/0/7 gigether-options 802.3ad ae0

set interfaces ae0 description vMX-2
set interfaces ae0 aggregated-ether-options lacp active

set interfaces ae0 unit 0 family inet address 10.100.0.0/31
set interfaces ae0 unit 0 family inet6 address 2001:db8:1000::0/127
</pre>


<b>vMX-2</b>:

<pre style="font-size:12px">
set chassis aggregated-devices ethernet device-count 20

set interfaces ge-0/0/4 gigether-options 802.3ad ae0
set interfaces ge-0/0/5 gigether-options 802.3ad ae0
set interfaces ge-0/0/6 gigether-options 802.3ad ae0
set interfaces ge-0/0/7 gigether-options 802.3ad ae0

set interfaces ae0 description vMX-1
set interfaces ae0 aggregated-ether-options lacp active

set interfaces ae0 unit 0 family inet address 10.100.0.1/31
set interfaces ae0 unit 0 family inet6 address 2001:db8:1000::1/127
</pre>


The first line enables the system to configure a total of 20 LAGs. Without this configuration, the Juniper device will not bring up any LAG. After this, we assign 4 interfaces to LAG AE0 and configure the AE0 interface itself. Here we configure the <b>aggregated-ether-options</b> to use LACP. Finally, we finish up configuring IP addresses on the AE interface.

Next up is the BFD sessions that protect the LAG. Those are configured as part of the <b>aggregated-ether-options</b> under the interface configuration of the LAG. We only need to specify the BFD session characteristics once in the AE configuration. This will make the Juniper device attempt to establish BFD sessions on every active child link that is participating in the LAG.

<b>vMX-1</b>:

<pre style="font-size:12px">
set interfaces ae0 aggregated-ether-options bfd-liveness-detection minimum-interval 100
set interfaces ae0 aggregated-ether-options bfd-liveness-detection neighbor 10.0.0.2
set interfaces ae0 aggregated-ether-options bfd-liveness-detection local-address 10.0.0.1

set interfaces lo0 unit 0 family inet address 10.0.0.1/32
</pre>

<b>vMX-2</b>:

<pre style="font-size:12px">
set interfaces ae0 aggregated-ether-options bfd-liveness-detection minimum-interval 100
set interfaces ae0 aggregated-ether-options bfd-liveness-detection neighbor 10.0.0.1
set interfaces ae0 aggregated-ether-options bfd-liveness-detection local-address 10.0.0.2

set interfaces lo0 unit 0 family inet address 10.0.0.2/32
</pre>

Alternatively, we can also choose to create the BFD sessions using IPv6 addresses. In that case, we could configure something like this:

<b>vMX-1</b>:

<pre style="font-size:12px">
set interfaces ae0 aggregated-ether-options bfd-liveness-detection minimum-interval 100
set interfaces ae0 aggregated-ether-options bfd-liveness-detection neighbor 2001:db8:1000::2
set interfaces ae0 aggregated-ether-options bfd-liveness-detection local-address 2001:db8:1000::1

set interfaces lo0 unit 0 family inet6 address 2001:db8:1000::1/128
</pre>

<b>vMX-2</b>:

<pre style="font-size:12px">
set interfaces ae0 aggregated-ether-options bfd-liveness-detection minimum-interval 100
set interfaces ae0 aggregated-ether-options bfd-liveness-detection neighbor 2001:db8:1000::1
set interfaces ae0 aggregated-ether-options bfd-liveness-detection local-address 2001:db8:1000::2

set interfaces lo0 unit 0 family inet6 address 2001:db8:1000::2/128
</pre>


### Verifying our work

To verify the BFD sessions, we can use the following command:
<pre style="font-size:12px">
salt@vMX-1> <b>show bfd session</b>
                                                  Detect   Transmit
Address                  State     Interface      Time     Interval  Multiplier
2001:db8:1000::2         Up        ge-0/0/7       0.300     0.100        3   
2001:db8:1000::2         Up        ge-0/0/6       0.300     0.100        3   
2001:db8:1000::2         Up        ge-0/0/5       0.300     0.100        3   
2001:db8:1000::2         Up        ge-0/0/4       0.300     0.100        3   

4 sessions, 4 clients
Cumulative transmit rate 40.0 pps, cumulative receive rate 40.0 pps
</pre>  

To verify the LAG, we can use the following commands:<br>

<pre style="font-size:12px">
salt@vMX-1> <b>show lacp interfaces ae0</b>
Aggregated interface: ae0
< output omitted >
    LACP protocol:        Receive State  Transmit State          Mux State 
      ge-0/0/4                  Current   Fast periodic Collecting distributing
      ge-0/0/5                  Current   Fast periodic Collecting distributing
      ge-0/0/6                  Current   Fast periodic Collecting distributing
      ge-0/0/7                  Current   Fast periodic Collecting distributing

salt@vMX-1> <b>show lacp statistics interfaces ae0</b>
Aggregated interface: ae0
    LACP Statistics:       LACP Rx     LACP Tx   Unknown Rx   Illegal Rx 
      ge-0/0/4               23439       23456            0            0
      ge-0/0/5               23440       23457            0            0
      ge-0/0/6               23440       23457            0            0
      ge-0/0/7               23439       23457            0            0

salt@vMX-1> <b>show interfaces ae0 extensive</b>
Physical interface: ae0, Enabled, Physical link is Up
  Interface index: 158, SNMP ifIndex: 541, Generation: 174
  Description: vMX-2
  Link-level type: Ethernet, MTU: 1514, <b>Speed: 4Gbps</b>, BPDU Error: None, MAC-REWRITE Error: None, Loopback: Disabled, Source filtering: Disabled, Flow control: Disabled
  Pad to minimum frame size: Disabled
  Minimum links needed: 1, Minimum bandwidth needed: 1bps
< output omitted >
    <b>Aggregate member links: 4</b>

    <b>BFD View</b> :           Link        Usable
                   ge-0/0/4.0         Yes
                   ge-0/0/5.0         Yes
                   ge-0/0/6.0         Yes
                   ge-0/0/7.0         Yes
    <b>LACP info</b>:        Role     System             System       Port     Port    Port 
                             priority         identifier   priority   number     key 
      ge-0/0/4.0     Actor        127  2c:6b:f5:c3:d4:c0        127        1       1
      ge-0/0/4.0   Partner        127  2c:6b:f5:07:da:c0        127        2       1
      ge-0/0/5.0     Actor        127  2c:6b:f5:c3:d4:c0        127        2       1
      ge-0/0/5.0   Partner        127  2c:6b:f5:07:da:c0        127        1       1
      ge-0/0/6.0     Actor        127  2c:6b:f5:c3:d4:c0        127        3       1
      ge-0/0/6.0   Partner        127  2c:6b:f5:07:da:c0        127        3       1
      ge-0/0/7.0     Actor        127  2c:6b:f5:c3:d4:c0        127        4       1
      ge-0/0/7.0   Partner        127  2c:6b:f5:07:da:c0        127        4       1
    LACP Statistics:       LACP Rx     LACP Tx   Unknown Rx   Illegal Rx 
      ge-0/0/4.0                 0           0            0            0
      ge-0/0/5.0                 0           0            0            0
      ge-0/0/6.0                 0           0            0            0
      ge-0/0/7.0                 0           0            0            0
    Marker Statistics:   Marker Rx     Resp Tx   Unknown Rx   Illegal Rx
      ge-0/0/4.0                 0           0            0            0
      ge-0/0/5.0                 0           0            0            0
      ge-0/0/6.0                 0           0            0            0
      ge-0/0/7.0                 0           0            0            0 
< output omitted >
</pre>      

This is supported on QFX as well, or at least on QFX10k. The configuration is the same except for the way in which you add a child link to the LAG.

<b>MX</b>:

<pre style="font-size:12px">
set interfaces et-0/0/0 <font color='red'>gigether-options</font> 802.3ad ae0
</pre>

<b>QFX<b>:

<pre style="font-size:12px">
set interfaces et-0/0/0 <font color='red'>ether-options</font> 802.3ad ae0
</pre>